import os
import sys
import time
import re
import pygame
from UnipyEngine.Input import Input

screen = None

class Engine:
    screen = None
    clock = None
    running = False

    @staticmethod
    def Init(width=800, height=800):
        pygame.init()
        Engine.screen = pygame.display.set_mode((width, height))
        Engine.clock = pygame.time.Clock()
        Engine.running = True
        Engine.screen.fill((0, 0, 0))
        pygame.display.flip()
        
    @staticmethod
    def Run():
        from UnipyEngine.Core import GameObject

        while Engine.running:
            Engine.screen.fill((0, 0, 0))
            dt = Engine.clock.tick(60) / 1000.0

            events = pygame.event.get()
            Input.UpdateEvents(events)  # mise à jour des inputs

            for gameObject in GameObject.instances:
                for component in gameObject.components:
                    if hasattr(component, "Update") and callable(component.Update):
                        component.Update(dt)

            pygame.display.flip()

            for event in events:
                if event.type == pygame.QUIT:
                    Engine.running = False

        Debug.LogSuccess("Exit")
        pygame.quit()

    @staticmethod
    def is_valid_module_name(filename: str) -> bool:
        """Vérifie si le nom de fichier correspond à un identifiant Python valide."""
        name = os.path.splitext(filename)[0]
        return re.match(r'^[A-Za-z_][A-Za-z0-9_]*$', name) is not None
    
    @staticmethod
    def LoadScripts(folder="Assets"):
        # nettoyer la console
        os.system("cls" if os.name == "nt" else "clear")
        time.sleep(0.5)

        if not os.path.exists(folder):
            Debug.LogError(f"UnipyEngine: Scripts folder '{folder}' not found")
            sys.exit(0)

        init_file = os.path.join(folder, "__init__.py")

        # 1. récupérer les scripts connus
        known_files = set()
        if os.path.exists(init_file):
            with open(init_file, "r", encoding="utf-8") as f:
                for line in f:
                    if line.startswith("from ."):
                        modname = line.split()[1].lstrip(".")
                        known_files.add(modname)

        # 2. récupérer les scripts actuels
        current_files = set(
            os.path.splitext(f)[0]
            for f in os.listdir(folder)
            if f.endswith(".py") and f != "__init__.py"
        )

        # 3. comparer
        added = current_files - known_files
        removed = known_files - current_files

        if added or removed:
            hasInvalidMod = False

            # affichage clair
            Debug.LogWarnig("UnipyEngine: Scripts changed, reloading required.\n")
            time.sleep(0.5)
            for mod in sorted(added):
                file = f"{mod}.py"
                if Engine.is_valid_module_name(file):
                    Debug.LogSuccess(f"   + {file}")
                else:
                    hasInvalidMod = True
                    Debug.LogWarnig(f"   [Invalid] {file}")
                time.sleep(0.5)
            for mod in sorted(removed):
                Debug.LogSuccess(f"   - {mod}.py")
                time.sleep(0.5)

            # régénérer __init__.py
            with open(init_file, "w", encoding="utf-8") as f:
                f.write("# Auto-generated by UnipyEngine.Engine\n")
                for file in sorted(os.listdir(folder)):
                    if file.endswith(".py") and file != "__init__.py":
                        module_name = os.path.splitext(file)[0]
                        if Engine.is_valid_module_name(file):
                            f.write(f"from .{module_name} import *\n")
                        else:
                            f.write(f"# [Invalid] {file}\n")

            if hasInvalidMod:
                print("\n")
                Debug.LogError("Module names must contain only letters, numbers and '_'\n")

            # petit délai pour lisibilité + arrêt du run
            time.sleep(1)
            Debug.LogSuccess("UnipyEngine: Reloading complete. Please restart.")
            sys.exit(0)
        else:
            Debug.LogSuccess("Loading Complete\n")
            time.sleep(0.5)

class Debug:
    def Log(log:str):
        print(f"\033[LOG]\033[0m : {log}")

    def LogSuccess(success:str):
        print(f"\033[92m[SUCCESS]\033[0m : {success}")

    def LogWarnig(warning:str):
        print(f"\033[93m[WARNING]\033[0m : {warning}")

    def LogError(error:str):
        print(f"\033[91m[ERROR]\033[0m : {error}")